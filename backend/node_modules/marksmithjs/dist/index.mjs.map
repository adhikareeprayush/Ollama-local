{"version":3,"sources":["../src/htmlnode/index.ts","../src/markdown/index.ts","../src/textnode/index.ts","../src/inline/index.ts","../src/block/utils.ts","../src/block/index.ts","../src/index.ts"],"sourcesContent":["interface Renderable {\n  toString(): string;\n  toHTML(): string;\n}\n\nexport class HTMLNode implements Renderable {\n  tag: string;\n  value: string;\n  children: Renderable[];\n  props: Map<string, string>;\n\n  constructor(\n    tag: string = \"\",\n    value: string = \"\",\n    children: Renderable[] = [],\n    props: Map<string, string>,\n  ) {\n    this.tag = tag;\n    this.value = value;\n    this.children = children;\n    this.props = props;\n  }\n\n  toHTML(): string {\n    throw new Error(\"Method 'toHTML' must be implemented in subclass.\");\n  }\n\n  toString(): string {\n    return `HTMLNode(${this.tag}, ${this.value}, ${this.children.toString()}, ${this.props})`;\n  }\n\n  propsToHTML(): string {\n    if (this.props.size === 0) {\n      return \"\";\n    }\n\n    const keys = Array.from(this.props.keys()).sort();\n\n    let htmlAttr = \"\";\n    for (const key of keys) {\n      htmlAttr += `${key}='${this.props.get(key)}' `;\n    }\n\n    htmlAttr = htmlAttr.trimEnd();\n\n    return htmlAttr;\n  }\n}\n\nexport class HTMLLeafNode extends HTMLNode {\n  constructor(\n    tag: string = \"\",\n    value: string = \"\",\n    props: Map<string, string> = new Map<string, string>(),\n  ) {\n    super(tag, value, [], props);\n  }\n\n  toString(): string {\n    return `LeafNode(${this.tag}, ${this.value}, ${this.children}, ${this.props})`;\n  }\n\n  toHTML(): string {\n    if (this.tag !== \"img\") {\n      if (this.value === \"\") {\n        throw new Error(\n          `Leaf node ${this.tag} does not have a value. ${this.toString()}`,\n        );\n      }\n    }\n\n    if (this.tag === \"\") {\n      return this.value;\n    }\n\n    const props = this.propsToHTML();\n    if (props !== \"\") {\n      return `<${this.tag} ${props}>${this.value}</${this.tag}>`;\n    }\n\n    return `<${this.tag}>${this.value}</${this.tag}>`;\n  }\n}\n\nexport class HTMLParentNode extends HTMLNode {\n  constructor(\n    tag: string = \"\",\n    value: string = \"\",\n    children: Renderable[] = [],\n    props: Map<string, string> = new Map<string, string>(),\n  ) {\n    super(tag, value, children, props);\n  }\n\n  toString(): string {\n    return `ParentNode(${this.tag}, ${this.value}, ${this.children}, ${this.props})`;\n  }\n\n  toHTML(): string {\n    if (this.tag === \"\") {\n      throw new Error(\"Parent node does not have a tag\");\n    }\n\n    if (this.children.length === 0) {\n      throw new Error(\"Parent node does not have children\");\n    }\n\n    let childNodes = \"\";\n    for (const child of this.children) {\n      const childHTML = child.toHTML();\n      childNodes += childHTML;\n    }\n\n    const props = this.propsToHTML();\n    if (props !== \"\") {\n      return `<${this.tag} ${props}>${childNodes}</${this.tag}>`\n    }\n\n    return `<${this.tag}>${childNodes}</${this.tag}>`\n  }\n}\n","export enum Markdown {\n  TEXT = \"text\",\n  BOLD = \"bold\",\n  ITALIC = \"italic\",\n  CODE = \"code\",\n  LINK = \"link\",\n  IMAGE = \"image\",\n}\n\nexport class MarkdownContent {\n  text: string;\n  url: string;\n\n  constructor(text: string = \"\", url: string = \"\") {\n    this.text = text;\n    this.url = url;\n  }\n\n  isEqual(md: MarkdownContent): boolean {\n    if (this.text === md.text && this.url === md.url) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport class MarkdownImage extends MarkdownContent {\n  constructor(text: string, url: string) {\n    super(text, url);\n  }\n\n  toString(): string {\n    return `MarkdownImage(${this.text}, ${this.url})`;\n  }\n}\n\nexport class MarkdownLink extends MarkdownContent {\n  constructor(text: string, url: string) {\n    super(text, url);\n  }\n\n  toString(): string {\n    return `MarkdownImage(${this.text}, ${this.url})`;\n  }\n}\n","export class TextNode {\n  text: string;\n  textType: string;\n  url: string;\n\n  constructor(text: string = \"\", textType: string = \"\", url: string = \"\") {\n    this.text = text;\n    this.textType = textType;\n    this.url = url;\n  }\n\n  toString(): string {\n    return `TextNode(${this.text}, ${this.textType}, ${this.url})`\n  }\n\n  isEqual(textNode: TextNode): boolean {\n    if (this.text === textNode.text && this.textType === textNode.textType && this.url === textNode.url) {\n      return true;\n    } \n    return false;\n  }\n}\n","import { HTMLLeafNode } from \"../htmlnode\";\nimport { Markdown, MarkdownImage, MarkdownLink } from \"../markdown\";\nimport { TextNode } from \"../textnode\";\n\nexport function textNodeToHTMLNode(node: TextNode) {\n  switch (node.textType) {\n    case Markdown.TEXT:\n      return new HTMLLeafNode(\"\", node.text);\n    case Markdown.BOLD:\n      return new HTMLLeafNode(\"b\", node.text);\n    case Markdown.ITALIC:\n      return new HTMLLeafNode(\"i\", node.text);\n    case Markdown.CODE:\n      return new HTMLLeafNode(\"code\", node.text);\n    case Markdown.LINK:\n      const linkProps = new Map<string, string>();\n      linkProps.set(\"href\", node.url);\n      return new HTMLLeafNode(\"a\", node.text, linkProps);\n    case Markdown.IMAGE:\n      const imgProps = new Map<string, string>();\n      imgProps.set(\"src\", node.url);\n      imgProps.set(\"alt\", node.text);\n      return new HTMLLeafNode(\"img\", \"\", imgProps);\n    default:\n      throw new Error(\"Text node type is not valid\");\n  }\n}\n\nexport function splitNodesDelimiter(\n  oldNodes: TextNode[],\n  delimiter: string,\n  textType: string,\n) {\n  const textNodes = new Array<TextNode>();\n\n  for (const oldNode of oldNodes) {\n    if (oldNode.textType !== Markdown.TEXT) {\n      textNodes.push(oldNode);\n      continue;\n    }\n\n    if (!oldNode.text.includes(delimiter)) {\n      textNodes.push(new TextNode(oldNode.text, oldNode.textType, oldNode.url));\n      continue;\n    }\n\n    const strs = oldNode.text.split(delimiter);\n\n    if (strs.length % 2 === 0) {\n      throw new Error(\n        `Invalid markdown syntax: ${oldNode.text} is not enclosed with ${delimiter}`,\n      );\n    }\n\n    for (let i = 0; i < strs.length; i++) {\n      if (strs[i] === \"\") {\n        continue;\n      }\n\n      if (i % 2 === 0) {\n        textNodes.push(new TextNode(strs[i], Markdown.TEXT));\n        continue;\n      }\n\n      textNodes.push(new TextNode(strs[i], textType));\n    }\n  }\n\n  return textNodes;\n}\n\nexport function extractMarkdownImages(text: string) {\n  const mdImages = new Array<MarkdownImage>();\n\n  const mdImageRegex = /!\\[(.*?)\\]\\((.*?)\\)/g;\n\n  let match;\n  while ((match = mdImageRegex.exec(text)) !== null) {\n    const altText = match[1];\n    const url = match[2];\n    mdImages.push(new MarkdownImage(altText, url));\n  }\n\n  return mdImages;\n}\n\nexport function extractMarkdownLinks(text: string) {\n  const mdLinks = new Array<MarkdownLink>();\n\n  const mdLinkRegex = /\\[(.*?)\\]\\((.*?)\\)/g;\n\n  let match;\n  while ((match = mdLinkRegex.exec(text)) !== null) {\n    const linkText = match[1];\n    const url = match[2];\n    mdLinks.push(new MarkdownLink(linkText, url));\n  }\n\n  return mdLinks;\n}\n\nexport function splitNodeImages(nodes: TextNode[]) {\n  const newNodes = new Array<TextNode>();\n\n  for (const node of nodes) {\n    if (node.textType !== Markdown.TEXT) {\n      newNodes.push(node);\n      continue;\n    }\n\n    const images = extractMarkdownImages(node.text);\n\n    if (images.length === 0) {\n      newNodes.push(node);\n      continue;\n    }\n\n    let imageText = node.text;\n    for (const image of images) {\n      const sections = imageText.split(`![${image.text}](${image.url})`);\n\n      if (sections.length !== 2) {\n        throw new Error(\n          `Invalid Markdown syntax. Image section is not closed for: ${image.text}`,\n        );\n      }\n\n      if (sections[0] !== \"\") {\n        newNodes.push(new TextNode(sections[0], Markdown.TEXT));\n      }\n\n      newNodes.push(new TextNode(image.text, Markdown.IMAGE, image.url));\n      imageText = sections[1];\n    }\n\n    if (imageText !== \"\") {\n      newNodes.push(new TextNode(imageText, Markdown.TEXT));\n    }\n  }\n  return newNodes;\n}\n\nexport function splitNodeLinks(nodes: TextNode[]) {\n  const newNodes = new Array<TextNode>();\n\n  for (const node of nodes) {\n    if (node.textType !== Markdown.TEXT) {\n      newNodes.push(node);\n      continue;\n    }\n\n    const links = extractMarkdownLinks(node.text);\n\n    if (links.length === 0) {\n      newNodes.push(node);\n      continue;\n    }\n\n    let linkText = node.text;\n    for (const link of links) {\n      const sections = linkText.split(`[${link.text}](${link.url})`);\n\n      if (sections.length !== 2) {\n        throw new Error(\n          `Invalid Markdown syntax. Image section is not closed for: ${link.text}`,\n        );\n      }\n\n      if (sections[0] !== \"\") {\n        newNodes.push(new TextNode(sections[0], Markdown.TEXT));\n      }\n\n      newNodes.push(new TextNode(link.text, Markdown.LINK, link.url));\n      linkText = sections[1];\n    }\n\n    if (linkText !== \"\") {\n      newNodes.push(new TextNode(linkText, Markdown.TEXT));\n    }\n  }\n  return newNodes;\n}\n\nexport function textToTextNodes(text: string) {\n  const node = new TextNode(text, Markdown.TEXT); \n\n  let newNodes = splitNodesDelimiter([node], \"**\", Markdown.BOLD);\n  newNodes = splitNodesDelimiter(newNodes, \"*\", Markdown.ITALIC);\n  newNodes = splitNodesDelimiter(newNodes, \"```\", Markdown.CODE);\n  newNodes = splitNodesDelimiter(newNodes, \"`\", Markdown.CODE);\n  newNodes = splitNodeImages(newNodes);\n  newNodes = splitNodeLinks(newNodes);\n\n  return newNodes;\n}\n","import { HTMLLeafNode } from \"../htmlnode\";\nimport { textNodeToHTMLNode, textToTextNodes } from \"../inline\";\n\nexport const headingRe = /^#{1,6}\\s.*$/m;\nexport const quoteRe = /^(>.+)$/gm;\nexport const ulRe = /^([*-]\\s.*\\n?)+$/gm;\nexport const olRe = /^((?:1|[2-9]\\d*)\\.\\s.*\\n?)+$/gm;\nexport const codeRe = /^```[\\s\\S]*?```$/m;\nexport const tableRe = /^\\|\\s.*?\\s\\|\\s.*?\\s\\|$/gm;\nexport const hrRe = /^---$/g;\n\nexport enum Block {\n  HEADING = \"heading\",\n  PARAGRAPH = \"paragraph\",\n  CODE = \"code\",\n  QUOTE = \"quote\",\n  UNORDERED_LIST = \"unordered_list\",\n  ORDERED_LIST = \"ordered_list\",\n  TABLE = \"table\",\n  HR = \"hr\",\n}\n\nexport function createHTMLHeading(block: string) {\n  const parts = block.split(\" \");\n  const content = [parts[0], parts.slice(1).join(\" \")];\n  const headingNumber = content[0].length;\n\n  const textNodes = textToTextNodes(content[1]);\n  const leafNodes = new Array<HTMLLeafNode>();\n\n  for (const textNode of textNodes) {\n    const leafNode = textNodeToHTMLNode(textNode);\n    leafNodes.push(leafNode);\n  }\n\n  let headingValue = \"\";\n\n  for (const leafNode of leafNodes) {\n    const leafHTML = leafNode.toHTML();\n    headingValue += leafHTML;\n  }\n\n  return `<h${headingNumber}>${headingValue}</h${headingNumber}>`;\n}\n\nexport function createHTMLParagraph(block: string) {\n  const textNodes = textToTextNodes(block);\n  const leafNodes = new Array<HTMLLeafNode>();\n\n  for (const textNode of textNodes) {\n    const leafNode = textNodeToHTMLNode(textNode);\n    leafNodes.push(leafNode);\n  }\n\n  let pValue = \"\";\n\n  for (const leafNode of leafNodes) {\n    const leafHTML = leafNode.toHTML();\n    pValue += leafHTML;\n  }\n\n  return `<p>${pValue}</p>`;\n}\n\nexport function createHTMLQuote(block: string) {\n  const content = block.split(\"\\n\");\n  const quoteBlocks = new Array<string>();\n\n  for (const quote of content) {\n    quoteBlocks.push(quote.split(\"> \")[1]);\n  }\n\n  let quote = \"\";\n\n  for (const quoteBlock of quoteBlocks) {\n    const textNodes = textToTextNodes(quoteBlock);\n    const leafNodes = new Array<HTMLLeafNode>();\n\n    for (const textNode of textNodes) {\n      const leafNode = textNodeToHTMLNode(textNode);\n      leafNodes.push(leafNode);\n    }\n\n    let quoteValue = \"\";\n\n    for (const leafNode of leafNodes) {\n      const leafHTML = leafNode.toHTML();\n      quoteValue += leafHTML;\n    }\n\n    quote += quoteValue;\n  }\n\n  return `<blockquote>${quote}</blockquote>`;\n}\n\nexport function createHTMLCode(block: string) {\n  const codeValue = block.slice(3,-3);\n  return `<pre><code>${codeValue}</code></pre>`;\n}\n\nexport function createHTMLOrderedList(block: string) {\n  const items = block.split(\"\\n\");\n  let listItems = \"\";\n\n  for (const item of items) {\n    const parts = item.split(\" \");\n    const content = [parts[0], parts.slice(1).join(\" \")]\n    let listValue = \"\";\n\n    const textNodes = textToTextNodes(content[1]);\n    const leafNodes = new Array<HTMLLeafNode>();\n\n    for (const textNode of textNodes) {\n      const leafNode = textNodeToHTMLNode(textNode);\n      leafNodes.push(leafNode);\n    }\n\n    for (const leafNode of leafNodes) {\n      const leafHTML = leafNode.toHTML();\n      listValue += leafHTML;\n    }\n\n    listItems += `<li>${listValue}</li>`;\n  }\n\n  return `<ol>${listItems}</ol>`;\n}\n\nexport function createHTMLUnorderedList(block: string) {\n  const items = block.split(\"\\n\");\n  let listItems = \"\";\n\n  for (const item of items) {\n    const parts = item.split(\" \");\n    const content = [parts[0], parts.slice(1).join(\" \")]\n    let listValue = \"\";\n\n    const textNodes = textToTextNodes(content[1]);\n    const leafNodes = new Array<HTMLLeafNode>();\n\n    for (const textNode of textNodes) {\n      const leafNode = textNodeToHTMLNode(textNode);\n      leafNodes.push(leafNode);\n    }\n\n    for (const leafNode of leafNodes) {\n      const leafHTML = leafNode.toHTML();\n      listValue += leafHTML;\n    }\n\n    listItems += `<li>${listValue}</li>`;\n  }\n\n  return `<ul>${listItems}</ul>`;\n}\n\nexport function createHTMLTable(block: string) {\n  let items = block.split(\"\\n\");\n  let tableItems = \"\";\n\n  if (items.length < 2) {\n    throw new Error(\"Table must have a atleast 2 lines\");\n  }\n\n  if (items[1].startsWith(\"|---\") || items[1].startsWith(\"| --\")) {\n    items.splice(1, 1);\n  }\n  const tableHeadings = items[0];\n  const tableHeaders = tableHeadings.split(\"|\").slice(1, -1);\n\n  let headers = \"\";\n  for (const tableHeader of tableHeaders) {\n    const tableHeading = createHTMLHeading(`### ${tableHeader.trim()}`);\n    headers += `<th>${tableHeading}</th>`;\n  }\n\n  tableItems += `<tr>${headers}</tr>`;\n\n  items = items.slice(1);\n\n  for (const tableRow of items) {\n    let tableData = tableRow.split(\"|\");\n    tableData = tableData.slice(1, -1);\n    let td = \"\";\n\n    for (const data of tableData) {\n      const tableDataItem = createHTMLParagraph(data.trim());\n      td += `<td>${tableDataItem}</td>`;\n    }\n\n    tableItems += `<tr>${td}</tr>`;\n  }\n\n  return `<table>${tableItems}</table>`;\n}\n\nexport function createHTMLHr() {\n  return \"<hr></hr>\"\n}\n","import {\n  Block,\n  headingRe,\n  quoteRe,\n  ulRe,\n  olRe,\n  tableRe,\n  codeRe,\n  createHTMLHeading,\n  createHTMLParagraph,\n  createHTMLTable,\n  createHTMLCode,\n  createHTMLQuote,\n  createHTMLOrderedList,\n  createHTMLUnorderedList,\n  hrRe,\n  createHTMLHr,\n} from \"./utils\";\n\nexport function markdownToBlocks(markdown: string) {\n  const blocks = new Array<string>();\n  const mdBlocks = markdown.split(\"\\n\\n\");\n\n  for (let mdBlock of mdBlocks) {\n    if (mdBlock !== \"\") {\n      mdBlock = mdBlock.trim();\n      blocks.push(mdBlock);\n    }\n  }\n\n  return blocks;\n}\n\nexport function blockToBlockType(block: string) {\n  if (headingRe.test(block)) {\n    return Block.HEADING;\n  } else if (quoteRe.test(block)) {\n    return Block.QUOTE;\n  } else if (ulRe.test(block)) {\n    return Block.UNORDERED_LIST;\n  } else if (olRe.test(block)) {\n    return Block.ORDERED_LIST;\n  } else if (codeRe.test(block)) {\n    return Block.CODE;\n  } else if (tableRe.test(block)) {\n    return Block.TABLE;\n  } else if (hrRe.test(block)) {\n    return Block.HR;\n  } else {\n    return Block.PARAGRAPH;\n  }\n}\n\nexport function markdownToHTMLNode(markdown: string) {\n  let html = \"<div>\";\n\n  const blocks = markdownToBlocks(markdown);\n\n  for (const block of blocks) {\n    const blockType = blockToBlockType(block);\n\n    switch (blockType) {\n      case Block.HEADING:\n        const heading = createHTMLHeading(block);\n        html += heading;\n        break;\n      case Block.PARAGRAPH:\n        const paragraph = createHTMLParagraph(block);\n        html += paragraph;\n        break;\n      case Block.CODE:\n        const code = createHTMLCode(block);\n        html += code;\n        break;\n      case Block.QUOTE:\n        const quote = createHTMLQuote(block);\n        html += quote;\n        break;\n      case Block.UNORDERED_LIST:\n        const ul = createHTMLUnorderedList(block);\n        html += ul;\n        break;\n      case Block.ORDERED_LIST:\n        const ol = createHTMLOrderedList(block);\n        html += ol;\n        break;\n      case Block.TABLE:\n        const table = createHTMLTable(block);\n        html += table;\n        break;\n      case Block.HR:\n        const hr = createHTMLHr();\n        html += hr;\n        break;\n      default:\n        throw new Error(\"Block type not recognized\");\n    }\n  }\n\n  html += \"</div>\";\n  return html;\n}\n","import { markdownToHTMLNode } from \"./block\";\n\nexport function markdownToHtml(markdown: string) {\n  const html = markdownToHTMLNode(markdown);\n  return html;\n}\n"],"mappings":"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","names":["quote"]}