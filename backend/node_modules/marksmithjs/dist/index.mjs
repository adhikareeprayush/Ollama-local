// src/htmlnode/index.ts
var HTMLNode = class {
  constructor(tag = "", value = "", children = [], props) {
    this.tag = tag;
    this.value = value;
    this.children = children;
    this.props = props;
  }
  toHTML() {
    throw new Error("Method 'toHTML' must be implemented in subclass.");
  }
  toString() {
    return `HTMLNode(${this.tag}, ${this.value}, ${this.children.toString()}, ${this.props})`;
  }
  propsToHTML() {
    if (this.props.size === 0) {
      return "";
    }
    const keys = Array.from(this.props.keys()).sort();
    let htmlAttr = "";
    for (const key of keys) {
      htmlAttr += `${key}='${this.props.get(key)}' `;
    }
    htmlAttr = htmlAttr.trimEnd();
    return htmlAttr;
  }
};
var HTMLLeafNode = class extends HTMLNode {
  constructor(tag = "", value = "", props = /* @__PURE__ */ new Map()) {
    super(tag, value, [], props);
  }
  toString() {
    return `LeafNode(${this.tag}, ${this.value}, ${this.children}, ${this.props})`;
  }
  toHTML() {
    if (this.tag !== "img") {
      if (this.value === "") {
        throw new Error(
          `Leaf node ${this.tag} does not have a value. ${this.toString()}`
        );
      }
    }
    if (this.tag === "") {
      return this.value;
    }
    const props = this.propsToHTML();
    if (props !== "") {
      return `<${this.tag} ${props}>${this.value}</${this.tag}>`;
    }
    return `<${this.tag}>${this.value}</${this.tag}>`;
  }
};

// src/markdown/index.ts
var MarkdownContent = class {
  constructor(text = "", url = "") {
    this.text = text;
    this.url = url;
  }
  isEqual(md) {
    if (this.text === md.text && this.url === md.url) {
      return true;
    }
    return false;
  }
};
var MarkdownImage = class extends MarkdownContent {
  constructor(text, url) {
    super(text, url);
  }
  toString() {
    return `MarkdownImage(${this.text}, ${this.url})`;
  }
};
var MarkdownLink = class extends MarkdownContent {
  constructor(text, url) {
    super(text, url);
  }
  toString() {
    return `MarkdownImage(${this.text}, ${this.url})`;
  }
};

// src/textnode/index.ts
var TextNode = class {
  constructor(text = "", textType = "", url = "") {
    this.text = text;
    this.textType = textType;
    this.url = url;
  }
  toString() {
    return `TextNode(${this.text}, ${this.textType}, ${this.url})`;
  }
  isEqual(textNode) {
    if (this.text === textNode.text && this.textType === textNode.textType && this.url === textNode.url) {
      return true;
    }
    return false;
  }
};

// src/inline/index.ts
function textNodeToHTMLNode(node) {
  switch (node.textType) {
    case "text" /* TEXT */:
      return new HTMLLeafNode("", node.text);
    case "bold" /* BOLD */:
      return new HTMLLeafNode("b", node.text);
    case "italic" /* ITALIC */:
      return new HTMLLeafNode("i", node.text);
    case "code" /* CODE */:
      return new HTMLLeafNode("code", node.text);
    case "link" /* LINK */:
      const linkProps = /* @__PURE__ */ new Map();
      linkProps.set("href", node.url);
      return new HTMLLeafNode("a", node.text, linkProps);
    case "image" /* IMAGE */:
      const imgProps = /* @__PURE__ */ new Map();
      imgProps.set("src", node.url);
      imgProps.set("alt", node.text);
      return new HTMLLeafNode("img", "", imgProps);
    default:
      throw new Error("Text node type is not valid");
  }
}
function splitNodesDelimiter(oldNodes, delimiter, textType) {
  const textNodes = new Array();
  for (const oldNode of oldNodes) {
    if (oldNode.textType !== "text" /* TEXT */) {
      textNodes.push(oldNode);
      continue;
    }
    if (!oldNode.text.includes(delimiter)) {
      textNodes.push(new TextNode(oldNode.text, oldNode.textType, oldNode.url));
      continue;
    }
    const strs = oldNode.text.split(delimiter);
    if (strs.length % 2 === 0) {
      throw new Error(
        `Invalid markdown syntax: ${oldNode.text} is not enclosed with ${delimiter}`
      );
    }
    for (let i = 0; i < strs.length; i++) {
      if (strs[i] === "") {
        continue;
      }
      if (i % 2 === 0) {
        textNodes.push(new TextNode(strs[i], "text" /* TEXT */));
        continue;
      }
      textNodes.push(new TextNode(strs[i], textType));
    }
  }
  return textNodes;
}
function extractMarkdownImages(text) {
  const mdImages = new Array();
  const mdImageRegex = /!\[(.*?)\]\((.*?)\)/g;
  let match;
  while ((match = mdImageRegex.exec(text)) !== null) {
    const altText = match[1];
    const url = match[2];
    mdImages.push(new MarkdownImage(altText, url));
  }
  return mdImages;
}
function extractMarkdownLinks(text) {
  const mdLinks = new Array();
  const mdLinkRegex = /\[(.*?)\]\((.*?)\)/g;
  let match;
  while ((match = mdLinkRegex.exec(text)) !== null) {
    const linkText = match[1];
    const url = match[2];
    mdLinks.push(new MarkdownLink(linkText, url));
  }
  return mdLinks;
}
function splitNodeImages(nodes) {
  const newNodes = new Array();
  for (const node of nodes) {
    if (node.textType !== "text" /* TEXT */) {
      newNodes.push(node);
      continue;
    }
    const images = extractMarkdownImages(node.text);
    if (images.length === 0) {
      newNodes.push(node);
      continue;
    }
    let imageText = node.text;
    for (const image of images) {
      const sections = imageText.split(`![${image.text}](${image.url})`);
      if (sections.length !== 2) {
        throw new Error(
          `Invalid Markdown syntax. Image section is not closed for: ${image.text}`
        );
      }
      if (sections[0] !== "") {
        newNodes.push(new TextNode(sections[0], "text" /* TEXT */));
      }
      newNodes.push(new TextNode(image.text, "image" /* IMAGE */, image.url));
      imageText = sections[1];
    }
    if (imageText !== "") {
      newNodes.push(new TextNode(imageText, "text" /* TEXT */));
    }
  }
  return newNodes;
}
function splitNodeLinks(nodes) {
  const newNodes = new Array();
  for (const node of nodes) {
    if (node.textType !== "text" /* TEXT */) {
      newNodes.push(node);
      continue;
    }
    const links = extractMarkdownLinks(node.text);
    if (links.length === 0) {
      newNodes.push(node);
      continue;
    }
    let linkText = node.text;
    for (const link of links) {
      const sections = linkText.split(`[${link.text}](${link.url})`);
      if (sections.length !== 2) {
        throw new Error(
          `Invalid Markdown syntax. Image section is not closed for: ${link.text}`
        );
      }
      if (sections[0] !== "") {
        newNodes.push(new TextNode(sections[0], "text" /* TEXT */));
      }
      newNodes.push(new TextNode(link.text, "link" /* LINK */, link.url));
      linkText = sections[1];
    }
    if (linkText !== "") {
      newNodes.push(new TextNode(linkText, "text" /* TEXT */));
    }
  }
  return newNodes;
}
function textToTextNodes(text) {
  const node = new TextNode(text, "text" /* TEXT */);
  let newNodes = splitNodesDelimiter([node], "**", "bold" /* BOLD */);
  newNodes = splitNodesDelimiter(newNodes, "*", "italic" /* ITALIC */);
  newNodes = splitNodesDelimiter(newNodes, "```", "code" /* CODE */);
  newNodes = splitNodesDelimiter(newNodes, "`", "code" /* CODE */);
  newNodes = splitNodeImages(newNodes);
  newNodes = splitNodeLinks(newNodes);
  return newNodes;
}

// src/block/utils.ts
var headingRe = /^#{1,6}\s.*$/m;
var quoteRe = /^(>.+)$/gm;
var ulRe = /^([*-]\s.*\n?)+$/gm;
var olRe = /^((?:1|[2-9]\d*)\.\s.*\n?)+$/gm;
var codeRe = /^```[\s\S]*?```$/m;
var tableRe = /^\|\s.*?\s\|\s.*?\s\|$/gm;
var hrRe = /^---$/g;
function createHTMLHeading(block) {
  const parts = block.split(" ");
  const content = [parts[0], parts.slice(1).join(" ")];
  const headingNumber = content[0].length;
  const textNodes = textToTextNodes(content[1]);
  const leafNodes = new Array();
  for (const textNode of textNodes) {
    const leafNode = textNodeToHTMLNode(textNode);
    leafNodes.push(leafNode);
  }
  let headingValue = "";
  for (const leafNode of leafNodes) {
    const leafHTML = leafNode.toHTML();
    headingValue += leafHTML;
  }
  return `<h${headingNumber}>${headingValue}</h${headingNumber}>`;
}
function createHTMLParagraph(block) {
  const textNodes = textToTextNodes(block);
  const leafNodes = new Array();
  for (const textNode of textNodes) {
    const leafNode = textNodeToHTMLNode(textNode);
    leafNodes.push(leafNode);
  }
  let pValue = "";
  for (const leafNode of leafNodes) {
    const leafHTML = leafNode.toHTML();
    pValue += leafHTML;
  }
  return `<p>${pValue}</p>`;
}
function createHTMLQuote(block) {
  const content = block.split("\n");
  const quoteBlocks = new Array();
  for (const quote2 of content) {
    quoteBlocks.push(quote2.split("> ")[1]);
  }
  let quote = "";
  for (const quoteBlock of quoteBlocks) {
    const textNodes = textToTextNodes(quoteBlock);
    const leafNodes = new Array();
    for (const textNode of textNodes) {
      const leafNode = textNodeToHTMLNode(textNode);
      leafNodes.push(leafNode);
    }
    let quoteValue = "";
    for (const leafNode of leafNodes) {
      const leafHTML = leafNode.toHTML();
      quoteValue += leafHTML;
    }
    quote += quoteValue;
  }
  return `<blockquote>${quote}</blockquote>`;
}
function createHTMLCode(block) {
  const codeValue = block.slice(3, -3);
  return `<pre><code>${codeValue}</code></pre>`;
}
function createHTMLOrderedList(block) {
  const items = block.split("\n");
  let listItems = "";
  for (const item of items) {
    const parts = item.split(" ");
    const content = [parts[0], parts.slice(1).join(" ")];
    let listValue = "";
    const textNodes = textToTextNodes(content[1]);
    const leafNodes = new Array();
    for (const textNode of textNodes) {
      const leafNode = textNodeToHTMLNode(textNode);
      leafNodes.push(leafNode);
    }
    for (const leafNode of leafNodes) {
      const leafHTML = leafNode.toHTML();
      listValue += leafHTML;
    }
    listItems += `<li>${listValue}</li>`;
  }
  return `<ol>${listItems}</ol>`;
}
function createHTMLUnorderedList(block) {
  const items = block.split("\n");
  let listItems = "";
  for (const item of items) {
    const parts = item.split(" ");
    const content = [parts[0], parts.slice(1).join(" ")];
    let listValue = "";
    const textNodes = textToTextNodes(content[1]);
    const leafNodes = new Array();
    for (const textNode of textNodes) {
      const leafNode = textNodeToHTMLNode(textNode);
      leafNodes.push(leafNode);
    }
    for (const leafNode of leafNodes) {
      const leafHTML = leafNode.toHTML();
      listValue += leafHTML;
    }
    listItems += `<li>${listValue}</li>`;
  }
  return `<ul>${listItems}</ul>`;
}
function createHTMLTable(block) {
  let items = block.split("\n");
  let tableItems = "";
  if (items.length < 2) {
    throw new Error("Table must have a atleast 2 lines");
  }
  if (items[1].startsWith("|---") || items[1].startsWith("| --")) {
    items.splice(1, 1);
  }
  const tableHeadings = items[0];
  const tableHeaders = tableHeadings.split("|").slice(1, -1);
  let headers = "";
  for (const tableHeader of tableHeaders) {
    const tableHeading = createHTMLHeading(`### ${tableHeader.trim()}`);
    headers += `<th>${tableHeading}</th>`;
  }
  tableItems += `<tr>${headers}</tr>`;
  items = items.slice(1);
  for (const tableRow of items) {
    let tableData = tableRow.split("|");
    tableData = tableData.slice(1, -1);
    let td = "";
    for (const data of tableData) {
      const tableDataItem = createHTMLParagraph(data.trim());
      td += `<td>${tableDataItem}</td>`;
    }
    tableItems += `<tr>${td}</tr>`;
  }
  return `<table>${tableItems}</table>`;
}
function createHTMLHr() {
  return "<hr></hr>";
}

// src/block/index.ts
function markdownToBlocks(markdown) {
  const blocks = new Array();
  const mdBlocks = markdown.split("\n\n");
  for (let mdBlock of mdBlocks) {
    if (mdBlock !== "") {
      mdBlock = mdBlock.trim();
      blocks.push(mdBlock);
    }
  }
  return blocks;
}
function blockToBlockType(block) {
  if (headingRe.test(block)) {
    return "heading" /* HEADING */;
  } else if (quoteRe.test(block)) {
    return "quote" /* QUOTE */;
  } else if (ulRe.test(block)) {
    return "unordered_list" /* UNORDERED_LIST */;
  } else if (olRe.test(block)) {
    return "ordered_list" /* ORDERED_LIST */;
  } else if (codeRe.test(block)) {
    return "code" /* CODE */;
  } else if (tableRe.test(block)) {
    return "table" /* TABLE */;
  } else if (hrRe.test(block)) {
    return "hr" /* HR */;
  } else {
    return "paragraph" /* PARAGRAPH */;
  }
}
function markdownToHTMLNode(markdown) {
  let html = "<div>";
  const blocks = markdownToBlocks(markdown);
  for (const block of blocks) {
    const blockType = blockToBlockType(block);
    switch (blockType) {
      case "heading" /* HEADING */:
        const heading = createHTMLHeading(block);
        html += heading;
        break;
      case "paragraph" /* PARAGRAPH */:
        const paragraph = createHTMLParagraph(block);
        html += paragraph;
        break;
      case "code" /* CODE */:
        const code = createHTMLCode(block);
        html += code;
        break;
      case "quote" /* QUOTE */:
        const quote = createHTMLQuote(block);
        html += quote;
        break;
      case "unordered_list" /* UNORDERED_LIST */:
        const ul = createHTMLUnorderedList(block);
        html += ul;
        break;
      case "ordered_list" /* ORDERED_LIST */:
        const ol = createHTMLOrderedList(block);
        html += ol;
        break;
      case "table" /* TABLE */:
        const table = createHTMLTable(block);
        html += table;
        break;
      case "hr" /* HR */:
        const hr = createHTMLHr();
        html += hr;
        break;
      default:
        throw new Error("Block type not recognized");
    }
  }
  html += "</div>";
  return html;
}

// src/index.ts
function markdownToHtml(markdown) {
  const html = markdownToHTMLNode(markdown);
  return html;
}
export {
  markdownToHtml
};
//# sourceMappingURL=index.mjs.map